<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeepStream Web</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; padding: 16px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 960px; margin: 0 auto; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
    input, button, select { font-size: 16px; padding: 8px; margin: 4px 0; width: 100%; box-sizing: border-box; }
    video { width: 100%; height: auto; background: #000; }
    .row { display: flex; gap: 8px; }
    .row > button { flex: 1; }
    .status { font-size: 14px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    async function health() {
      const el = document.getElementById('health');
      try { const r = await fetch('/api/health'); const j = await r.json(); el.textContent = JSON.stringify(j); } catch (e) { el.textContent = e.message; }
    }
    async function addStream() {
      const uri = document.getElementById('streamUri').value;
      const payload = { stream_id: 'stream_0', uri, source_id: 0 };
      const r = await fetch('/api/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const j = await r.json(); document.getElementById('status').textContent = JSON.stringify(j);
    }
    async function removeStream() {
      const r = await fetch('/api/stream/stream_0', { method: 'DELETE' });
      const j = await r.json(); document.getElementById('status').textContent = JSON.stringify(j);
    }
    function playHls() {
      const url = document.getElementById('hlsUrl').value;
      const video = document.getElementById('video');
      const isM3U8 = url.toLowerCase().endsWith('.m3u8');
      if (isM3U8 && window.Hls && Hls.isSupported()) { const hls = new Hls(); hls.loadSource(url); hls.attachMedia(video); } else { video.src = url; }
      video.play();
    }
    async function updateInference() {
      const payload = {
        infer_name: document.getElementById('inferName').value || 'primary-detector',
        batch_size: Number(document.getElementById('batchSize').value || 1),
        interval: Number(document.getElementById('interval').value || 1),
        gpu_id: Number(document.getElementById('gpuId').value || 0)
      };
      try {
        const r = await fetch('/api/infer', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const j = await r.json(); document.getElementById('inferStatus').textContent = JSON.stringify(j);
      } catch (e) {
        document.getElementById('inferStatus').textContent = e.message;
      }
    }
    async function addROI() {
      const payload = {
        stream_id: document.getElementById('roiStreamId').value || 'stream_0',
        roi_id: document.getElementById('roiId').value || 'roi_0',
        left: Number(document.getElementById('roiLeft').value || 0),
        top: Number(document.getElementById('roiTop').value || 0),
        width: Number(document.getElementById('roiWidth').value || 100),
        height: Number(document.getElementById('roiHeight').value || 100)
      };
      try {
        const r = await fetch('/api/roi', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const j = await r.json(); document.getElementById('roiStatus').textContent = JSON.stringify(j);
      } catch (e) {
        document.getElementById('roiStatus').textContent = e.message;
      }
    }
    async function sendMessage() {
      const text = document.getElementById('msgText').value || '';
      try {
        const r = await fetch('/api/message', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) });
        const j = await r.json(); document.getElementById('msgStatus').textContent = JSON.stringify(j);
        await loadMessages();
      } catch (e) {
        document.getElementById('msgStatus').textContent = e.message;
      }
    }
    async function loadMessages() {
      try {
        const r = await fetch('/api/message');
        const j = await r.json();
        const lines = (j.messages || []).slice(-50).map(m => new Date(m.ts).toISOString() + ' ' + m.text).join('\n');
        document.getElementById('msgList').textContent = lines || '(no messages)';
      } catch (e) {
        document.getElementById('msgList').textContent = e.message;
      }
    }
    async function clearMessages() {
      try {
        const r = await fetch('/api/message', { method: 'DELETE' });
        const j = await r.json();
        document.getElementById('msgStatus').textContent = JSON.stringify(j);
        await loadMessages();
      } catch (e) {
        document.getElementById('msgStatus').textContent = e.message;
      }
    }
    async function localHealth() {
      try {
        const r = await fetch('/api/local-health');
        const j = await r.json();
        document.getElementById('localHealth').textContent = JSON.stringify(j);
      } catch (e) {
        document.getElementById('localHealth').textContent = e.message;
      }
    }
    function setTab(name) { const ids = ['tab-input','tab-pipeline','tab-utility']; ids.forEach(id => { const el = document.getElementById(id); if (el) el.style.display = id === 'tab-'+name ? '' : 'none'; }); try { location.hash = '#'+name; } catch {} }
    function initTabs() { let t = (location.hash||'').replace('#',''); if (!t) t = 'input'; setTab(t); }
    window.addEventListener('load', () => { initTabs(); health(); loadMessages(); localHealth(); loadSamples(); });
  </script>
  </head>
<body>
  <div class="row" id="tabbar">
    <button onclick="setTab('input')">Input</button>
    <button onclick="setTab('pipeline')">Process Pipeline</button>
    <button onclick="setTab('utility')">Utility</button>
  </div>
  <div class="grid" id="tab-input">
    <div class="card">
      <h2>Video</h2>
      <input id="hlsUrl" placeholder="/video/stream.m3u8 or /media/bird.mp4" value="rtsp://127.0.0.1:8554/ds-test" />
      <div class="row">
        <button onclick="playHls()">Play</button>
        <button onclick="startHls()">Start HLS</button>
        <button onclick="stopHls()">Stop HLS</button>
        <button onclick="logsHls()">Logs</button>
      </div>
      <video id="video" playsinline controls muted></video>
      <div class="status" id="hlsStatus"></div>
    </div>
    <div class="card">
      <h2>Control</h2>
      <input id="streamUri" placeholder="rtsp://camera-ip/stream" />
      <div class="row">
        <button onclick="addStream()">Add Stream</button>
        <button onclick="removeStream()">Remove Stream</button>
      </div>
      <div class="status" id="status"></div>
      <h3>Health</h3>
      <div class="status" id="health"></div>
    </div>
  </div>
  <div class="grid" id="tab-pipeline" style="display:none">
    <div class="card">
      <h2>Inference</h2>
      <input id="inferName" placeholder="primary-detector" />
      <input id="batchSize" type="number" placeholder="batch size" />
      <input id="interval" type="number" placeholder="interval" />
      <input id="gpuId" type="number" placeholder="gpu id" />
      <div class="row">
        <button onclick="updateInference()">Update Inference</button>
      </div>
      <div class="status" id="inferStatus"></div>
    </div>
    <div class="card">
      <h2>ROI</h2>
      <input id="roiStreamId" placeholder="stream_0" />
      <input id="roiId" placeholder="roi_0" />
      <input id="roiLeft" type="number" placeholder="left" />
      <input id="roiTop" type="number" placeholder="top" />
      <input id="roiWidth" type="number" placeholder="width" />
      <input id="roiHeight" type="number" placeholder="height" />
      <div class="row">
        <button onclick="addROI()">Add/Update ROI</button>
      </div>
      <div class="status" id="roiStatus"></div>
    </div>
    <div class="card">
      <h2>DeepStream Samples</h2>
      <select id="dsSample"></select>
      <select id="dsIniList" size="6" style="width:100%" onchange="selectDsIniFromList()"></select>
      <textarea id="dsUris" rows="3" placeholder="Optional file paths. For Custom INI, put absolute /app/configs/... on first line"></textarea>
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="dsAutoEngine" /> Auto-build engine (remove model-engine-file)</label>
      <input id="dsImage" placeholder="Optional image override (e.g., siridech/deepstream-l4t:6.0.1-triton-prebuilt)" />
      <div class="row">
        <button onclick="loadSamples()">List</button>
        <button onclick="listDsIni()">List INIs</button>
        <button onclick="startDsApp()">Run</button>
        <button onclick="stopDsApp()">Stop</button>
        <button onclick="logsDsApp()">Logs</button>
      </div>
      <div class="status" id="dsStatus"></div>
      <div class="status" id="dsLogs" style="white-space:pre-wrap"></div>
    </div>
    <div class="card">
      <h2>INI Editor</h2>
      <input id="iniPath" placeholder="/app/configs/source1_fp16.ini" />
      <textarea id="iniText" rows="12" style="width:100%;height:240px" placeholder="Paste INI content here"></textarea>
      <select id="iniList" size="6" style="width:100%" onchange="selectIniFromList()"></select>
      <div class="row">
        <label style="flex:1">Text size <input id="osdTextSize" type="range" min="10" max="48" value="26" /></label>
        <label style="flex:1">BG opacity <input id="osdBgOpacity" type="range" min="0" max="255" value="160" /></label>
        <label style="flex:1">Confidence <input id="osdThreshold" type="number" step="0.05" min="0" max="1" value="0.5" /></label>
      </div>
      <div class="row">
        <button onclick="listIni()">List</button>
        <button onclick="loadIni()">Load</button>
        <button onclick="saveIni()">Save</button>
        <button onclick="runIni()">Run</button>
        <button onclick="patchIniLabels()">Patch Labels</button>
        <button onclick="patchOsdSettings()">Apply OSD</button>
      </div>
      <div class="status" id="iniStatus"></div>
    </div>
    <div class="card">
      <h2>Labels</h2>
      <input id="labelsPath" placeholder="/app/configs/labels.txt" />
      <textarea id="labelsText" rows="10" style="width:100%;height:200px" placeholder="One label per line"></textarea>
      <div class="row">
        <button onclick="loadLabels()">Load</button>
        <button onclick="saveLabels()">Save</button>
      </div>
      <div class="status" id="labelsStatus"></div>
    </div>
  </div>
  <div class="grid" id="tab-utility" style="display:none">
    <div class="card">
      <h2>Messages</h2>
      <textarea id="msgText" rows="8" style="width:100%;height:160px" placeholder="Type a message to send"></textarea>
      <div class="row">
        <button onclick="sendMessage()">Send</button>
        <button onclick="loadMessages()">Refresh</button>
        <button onclick="clearMsgText()">Clear Text</button>
        <button onclick="clearMessages()">Clear</button>
      </div>
      <div class="status" id="msgStatus"></div>
      <div class="status" id="msgList" style="white-space:pre-wrap"></div>
    </div>
    <div class="card">
      <h2>Snapshot</h2>
      <input id="snapUri" placeholder="rtsp://... or /data/videos/file.mp4" />
      <input id="snapRate" type="number" placeholder="rate per second" />
      <select id="mediaList" size="6" style="width:100%" onchange="selectMediaFile()"></select>
      <div class="row">
        <button onclick="listMedia()">List Media</button>
        <button onclick="useVideoForSnap()">Use Video</button>
        <button onclick="startSnap()">Start</button>
        <button onclick="stopSnap()">Stop</button>
        <button onclick="clearSnap()">Clear Images</button>
        <button onclick="loadSnapLogs()">Logs</button>
      </div>
      <div class="status" id="snapStatus"></div>
      <div class="status" id="snapCount"></div>
      <div id="snapViewer" style="display:flex;flex-direction:column;gap:8px;align-items:center;">
        <img id="snapImage" style="max-width:100%;height:auto;object-fit:contain" />
        <div class="row" style="width:100%">
          <button onclick="prevSnap()">Prev</button>
          <div id="snapIndex" class="status" style="text-align:center"></div>
          <button onclick="nextSnap()">Next</button>
        </div>
      </div>
    </div>
    <div class="card">
      <h2>System Health</h2>
      <div class="row">
        <button onclick="localHealth()">Refresh</button>
      </div>
      <div class="status" id="localHealth"></div>
    </div>
  </div>
  <script>
    async function startSnap() {
      let uri = document.getElementById('snapUri').value || '';
      if (!uri) { uri = document.getElementById('hlsUrl').value || ''; }
      const rate = Number(document.getElementById('snapRate').value || 1);
      try {
        const r = await fetch('/api/snapshot/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uri, rate }) });
        const j = await r.json(); document.getElementById('snapStatus').textContent = JSON.stringify(j);
        try { const c = (typeof j.count === 'number') ? j.count : 0; document.getElementById('snapCount').textContent = 'Images: ' + c; } catch {}
        await loadSnapImages(false);
        if (window.snapTimer) clearInterval(window.snapTimer);
        window.snapTimer = setInterval(async () => { await loadSnapImages(false); await localHealth(); }, 3000);
      } catch (e) {
        document.getElementById('snapStatus').textContent = e.message;
      }
    }
    function useVideoForSnap() {
      const url = document.getElementById('hlsUrl').value || '';
      document.getElementById('snapUri').value = url;
    }
    async function stopSnap() {
      try {
        const r = await fetch('/api/snapshot/stop', { method: 'POST' });
        const j = await r.json(); document.getElementById('snapStatus').textContent = JSON.stringify(j);
        await loadSnapImages(true);
        if (window.snapTimer) { clearInterval(window.snapTimer); window.snapTimer = null; }
      } catch (e) {
        document.getElementById('snapStatus').textContent = e.message;
      }
    }
    async function loadSnapLogs() {
      try {
        const r = await fetch('/api/snapshot/logs');
        const t = await r.text();
        document.getElementById('snapStatus').textContent = t;
      } catch (e) { document.getElementById('snapStatus').textContent = e.message; }
    }
    async function clearSnap() {
      try {
        const r = await fetch('/api/snapshot/clear', { method: 'DELETE' });
        const j = await r.json();
        document.getElementById('snapStatus').textContent = JSON.stringify(j);
        window.snapFiles = [];
        window.snapIndex = 0;
        try { document.getElementById('snapCount').textContent = 'Images: 0'; } catch {}
        renderSnap();
        await loadSnapImages(true);
      } catch (e) {
        document.getElementById('snapStatus').textContent = e.message;
      }
    }
    async function listMedia() { try { const r = await fetch('/api/media/list'); const j = await r.json(); const sel = document.getElementById('mediaList'); sel.innerHTML=''; if (j && Array.isArray(j.files)) { (j.files||[]).forEach(p => { const o=document.createElement('option'); o.value=p; o.textContent=p.replace('/media/',''); sel.appendChild(o); }); } else { document.getElementById('snapStatus').textContent = (j && j.error) ? j.error : 'No media found'; } } catch (e) { document.getElementById('snapStatus').textContent = e.message; } }
    function selectMediaFile() { const sel=document.getElementById('mediaList'); const p=sel.value||''; document.getElementById('snapUri').value = p; }
    async function loadSnapImages(limitAll) {
      try {
        const r = await fetch('/api/snapshot/list' + (limitAll ? '?limit=100000' : ''));
        const j = await r.json();
        const files = j.files || [];
        const prevLen = (window.snapFiles && window.snapFiles.length) || 0;
        window.snapFiles = files;
        try { document.getElementById('snapCount').textContent = 'Images: ' + files.length; } catch {}
        if (files.length === 0) { window.snapIndex = 0; renderSnap(); return; }
        if (prevLen === 0) { window.snapIndex = files.length - 1; } else { if (window.snapIndex >= files.length) window.snapIndex = files.length - 1; }
        renderSnap();
      } catch (e) {}
    }
    function renderSnap() {
      const imgEl = document.getElementById('snapImage');
      const idxEl = document.getElementById('snapIndex');
      const files = window.snapFiles || [];
      if (!files.length) { imgEl.removeAttribute('src'); idxEl.textContent = '(no images)'; return; }
      const i = Math.max(0, Math.min(window.snapIndex || 0, files.length - 1));
      window.snapIndex = i;
      imgEl.src = '/snapshots/' + files[i];
      idxEl.textContent = (i + 1) + '/' + files.length;
    }
    function prevSnap() { const n = (window.snapFiles || []).length; if (!n) return; window.snapIndex = (window.snapIndex + n - 1) % n; renderSnap(); }
    function nextSnap() { const n = (window.snapFiles || []).length; if (!n) return; window.snapIndex = (window.snapIndex + 1) % n; renderSnap(); }
    function clearMsgText() { document.getElementById('msgText').value = ''; }
    async function loadSamples() { try { const r = await fetch('/api/dsapp/samples'); const j = await r.json(); const sel = document.getElementById('dsSample'); sel.innerHTML = ''; (j.samples||[]).forEach(s => { const o = document.createElement('option'); o.value = s.id; o.textContent = s.label; sel.appendChild(o); }); } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    async function startDsApp() { const sample = document.getElementById('dsSample').value || 'test1'; const image = document.getElementById('dsImage').value || ''; const text = document.getElementById('dsUris').value || ''; const uris = text.split('\n').map(s => s.trim()).filter(Boolean); const autoEngine = !!document.getElementById('dsAutoEngine').checked; try { const r = await fetch('/api/dsapp/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sample, uris, image, autoEngine }) }); const j = await r.json(); document.getElementById('dsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    async function stopDsApp() { try { const r = await fetch('/api/dsapp/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('dsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    async function logsDsApp() { try { const r = await fetch('/api/dsapp/logs'); const t = await r.text(); document.getElementById('dsLogs').textContent = t; } catch (e) { document.getElementById('dsLogs').textContent = e.message; } }
    async function loadIni() { try { const p = document.getElementById('iniPath').value || ''; const r = await fetch('/api/configs/read?path=' + encodeURIComponent(p)); const j = await r.json(); if (j.content !== undefined) { document.getElementById('iniText').value = j.content; document.getElementById('iniStatus').textContent = 'Loaded'; } else { document.getElementById('iniStatus').textContent = JSON.stringify(j); } } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    async function saveIni() { try { const p = document.getElementById('iniPath').value || ''; const content = document.getElementById('iniText').value || ''; const r = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: p, content }) }); const j = await r.json(); document.getElementById('iniStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    async function listIni() { try { const r = await fetch('/api/configs/list?dir=' + encodeURIComponent('/app/configs/')); const j = await r.json(); const sel = document.getElementById('iniList'); sel.innerHTML = ''; if (j && Array.isArray(j.files)) { const prefix = (j && j.dir) || '/app/configs/'; (j.files||[]).forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p.startsWith(prefix) ? p.slice(prefix.length) : p.replace('/app/configs/',''); sel.appendChild(o); }); document.getElementById('iniStatus').textContent = 'Found ' + (j.files||[]).length + ' INIs'; } else { document.getElementById('iniStatus').textContent = (j && j.error) ? j.error : 'No INIs found'; } } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    function selectIniFromList() { const sel = document.getElementById('iniList'); const p = sel.value || ''; document.getElementById('iniPath').value = p; loadIni(); }
    async function runIni() { const p = document.getElementById('iniPath').value || ''; const image = document.getElementById('dsImage').value || ''; const autoEngine = !!document.getElementById('dsAutoEngine').checked; try { const r = await fetch('/api/dsapp/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sample: 'app_custom_ini', uris: [p], image, autoEngine }) }); const j = await r.json(); document.getElementById('iniStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    async function startHls() {
      let uri = document.getElementById('streamUri').value || '';
      if (!uri) { uri = document.getElementById('hlsUrl').value || ''; }
      try {
        const r = await fetch('/api/hls/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uri }) });
        const j = await r.json();
        document.getElementById('hlsStatus').textContent = JSON.stringify(j);
        if (j.playlist) {
          document.getElementById('hlsUrl').value = j.playlist;
          for (let i = 0; i < 20; i++) {
            try {
              const resp = await fetch(j.playlist, { cache: 'no-store' });
              if (resp.ok) { playHls(); break; }
            } catch {}
            await new Promise(res => setTimeout(res, 500));
          }
        }
      } catch (e) { document.getElementById('hlsStatus').textContent = e.message; }
    }
    async function stopHls() { try { const r = await fetch('/api/hls/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('hlsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('hlsStatus').textContent = e.message; } }
    async function logsHls() { try { const r = await fetch('/api/hls/logs'); const t = await r.text(); document.getElementById('hlsStatus').textContent = t; } catch (e) { document.getElementById('hlsStatus').textContent = e.message; } }
    async function patchIniLabels() {
      const iniPath = document.getElementById('iniPath').value || '/app/configs/rtsp_osd.ini';
      let txt = document.getElementById('iniText').value || '';
      let lines = txt.split(/\r?\n/);
      let inPrimary = false, sawCfg = false, patched = [];
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        const s = l.trim();
        if (s.startsWith('[') && s.endsWith(']')) {
          if (inPrimary && !sawCfg) { patched.push('config-file=/app/configs/pgie_primary.txt'); }
          inPrimary = /\[\s*primary-gie\s*\]/i.test(s);
          sawCfg = false;
          patched.push(l);
          continue;
        }
        if (inPrimary && /^\s*config-file\s*=\s*/i.test(s)) { patched.push('config-file=/app/configs/pgie_primary.txt'); sawCfg = true; continue; }
        patched.push(l);
      }
      if (!/\[\s*primary-gie\s*\]/i.test('\n'+txt)) {
        patched.push('[primary-gie]');
        patched.push('config-file=/app/configs/pgie_primary.txt');
      }
      if (!/\[\s*osd\s*\]/i.test('\n'+txt)) {
        patched.push('[osd]');
        patched.push('enable=1');
        patched.push('display-text=1');
      } else {
        let osdLines = [];
        inPrimary = false; let inOsd = false; lines.forEach((l) => { const s=l.trim(); if (s.startsWith('[') && s.endsWith(']')) { inOsd = /\[\s*osd\s*\]/i.test(s); } });
      }
      const newTxt = patched.join('\n');
      document.getElementById('iniText').value = newTxt;
      const pgie = [
        '[property]',
        'gpu-id=0',
        'network-type=0',
        'model-file=/opt/nvidia/deepstream/deepstream-6.0/samples/models/Primary_Detector/resnet10.caffemodel',
        'proto-file=/opt/nvidia/deepstream/deepstream-6.0/samples/models/Primary_Detector/resnet10.prototxt',
        'batch-size=1',
        'interval=0',
        'gie-unique-id=1',
        'maintain-aspect-ratio=1',
        'labelfile-path=/app/configs/labels.txt'
      ].join('\n');
      try {
        const r = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: '/app/configs/pgie_primary.txt', content: pgie }) });
        const j = await r.json();
        document.getElementById('iniStatus').textContent = 'Patched. PGIE: ' + JSON.stringify(j);
      } catch (e) {
        document.getElementById('iniStatus').textContent = e.message;
      }
    }
    async function patchOsdSettings() {
      const textSize = Number(document.getElementById('osdTextSize').value || 26);
      const bgOpacity = Number(document.getElementById('osdBgOpacity').value || 160);
      const threshold = Number(document.getElementById('osdThreshold').value || 0.5);
      let txt = document.getElementById('iniText').value || '';
      let lines = txt.split(/\r?\n/);
      let patched = [];
      let inOsd = false;
      let sawOsd = false;
      let sawEnable = false, sawDisplay = false, sawTextSize = false, sawBg = false;
      let osdHeaderIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        const s = l.trim();
        if (s.startsWith('[') && s.endsWith(']')) {
          inOsd = /\[\s*osd\s*\]/i.test(s);
          if (inOsd) { sawOsd = true; osdHeaderIndex = patched.length; }
          patched.push(l);
          continue;
        }
        if (inOsd) {
          if (/^\s*enable\s*=\s*/i.test(s)) { patched.push('enable=1'); sawEnable = true; continue; }
          if (/^\s*display-text\s*=\s*/i.test(s)) { patched.push('display-text=1'); sawDisplay = true; continue; }
          if (/^\s*text-size\s*=\s*/i.test(s)) { patched.push('text-size=' + textSize); sawTextSize = true; continue; }
          if (/^\s*text-bg-color\s*=\s*/i.test(s)) { patched.push(`text-bg-color=0;0;0;${bgOpacity}`); sawBg = true; continue; }
        }
        patched.push(l);
      }
      if (!sawOsd) {
        patched.push('[osd]');
        patched.push('enable=1');
        patched.push('display-text=1');
        patched.push('text-size=' + textSize);
        patched.push('text-bg-color=0;0;0;' + bgOpacity);
      } else {
        const insertAt = osdHeaderIndex + 1;
        const toInsert = [];
        if (!sawEnable) toInsert.push('enable=1');
        if (!sawDisplay) toInsert.push('display-text=1');
        if (!sawTextSize) toInsert.push('text-size=' + textSize);
        if (!sawBg) toInsert.push('text-bg-color=0;0;0;' + bgOpacity);
        if (toInsert.length) {
          patched = patched.slice(0, insertAt).concat(toInsert).concat(patched.slice(insertAt));
        }
      }
      const newTxt = patched.join('\n');
      document.getElementById('iniText').value = newTxt;
      try {
        let ptxt = '';
        try {
          const r1 = await fetch('/api/configs/read?path=' + encodeURIComponent('/app/configs/pgie_primary.txt'));
          const j1 = await r1.json();
          if (j1.content !== undefined) { ptxt = j1.content; }
        } catch {}
        if (!ptxt) {
          ptxt = [
            '[property]',
            'gpu-id=0',
            'network-type=0',
            'model-file=/opt/nvidia/deepstream/deepstream-6.0/samples/models/Primary_Detector/resnet10.caffemodel',
            'proto-file=/opt/nvidia/deepstream/deepstream-6.0/samples/models/Primary_Detector/resnet10.prototxt',
            'batch-size=1',
            'interval=0',
            'gie-unique-id=1',
            'maintain-aspect-ratio=1',
            'labelfile-path=/app/configs/labels.txt'
          ].join('\n');
        }
        let plines = ptxt.split(/\r?\n/);
        let ppatched = [];
        let inProp = false; let sawProp = false; let sawThreshold = false; let propHeaderIndex = -1;
        for (let i = 0; i < plines.length; i++) {
          const l = plines[i];
          const s = l.trim();
          if (s.startsWith('[') && s.endsWith(']')) {
            inProp = /\[\s*property\s*\]/i.test(s);
            if (inProp) { sawProp = true; propHeaderIndex = ppatched.length; }
            ppatched.push(l);
            continue;
          }
          if (inProp && /^\s*threshold\s*=\s*/i.test(s)) { ppatched.push('threshold=' + threshold); sawThreshold = true; continue; }
          ppatched.push(l);
        }
        if (!sawProp) { ppatched.push('[property]'); propHeaderIndex = ppatched.length - 1; }
        if (!sawThreshold) {
          const insertAt2 = propHeaderIndex + 1;
          ppatched = ppatched.slice(0, insertAt2).concat(['threshold=' + threshold]).concat(ppatched.slice(insertAt2));
        }
        const saveR = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: '/app/configs/pgie_primary.txt', content: ppatched.join('\n') }) });
        const saveJ = await saveR.json();
        document.getElementById('iniStatus').textContent = 'OSD applied. PGIE threshold: ' + JSON.stringify(saveJ);
      } catch (e) {
        document.getElementById('iniStatus').textContent = e.message;
      }
    }
    async function listDsIni() { try { const r = await fetch('/api/configs/list?dir=' + encodeURIComponent('/app/configs/')); const j = await r.json(); const sel = document.getElementById('dsIniList'); sel.innerHTML = ''; if (j && Array.isArray(j.files)) { const prefix = (j && j.dir) || '/app/configs/'; (j.files||[]).forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p.startsWith(prefix) ? p.slice(prefix.length) : p.replace('/app/configs/',''); sel.appendChild(o); }); document.getElementById('dsStatus').textContent = 'Found ' + (j.files||[]).length + ' INIs'; } else { document.getElementById('dsStatus').textContent = (j && j.error) ? j.error : 'No INIs found'; } } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    function selectDsIniFromList() { const sel = document.getElementById('dsIniList'); const p = sel.value || ''; const text = document.getElementById('dsUris').value || ''; const lines = text.split(/\r?\n/); lines[0] = p; document.getElementById('dsUris').value = lines.join('\n'); }
    async function loadLabels() { try { const p = document.getElementById('labelsPath').value || ''; const r = await fetch('/api/configs/read?path=' + encodeURIComponent(p)); const j = await r.json(); if (j.content !== undefined) { document.getElementById('labelsText').value = j.content; document.getElementById('labelsStatus').textContent = 'Loaded'; } else { document.getElementById('labelsStatus').textContent = JSON.stringify(j); } } catch (e) { document.getElementById('labelsStatus').textContent = e.message; } }
    async function saveLabels() { try { const p = document.getElementById('labelsPath').value || '/app/configs/labels.txt'; const content = document.getElementById('labelsText').value || ''; const r = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: p, content }) }); const j = await r.json(); document.getElementById('labelsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('labelsStatus').textContent = e.message; } }
  </script>
</body>
</html>