<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeepStream Web</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; padding: 16px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 960px; margin: 0 auto; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
    input, button, select { font-size: 16px; padding: 8px; margin: 4px 0; width: 100%; box-sizing: border-box; }
    video { width: 100%; height: auto; background: #000; }
    .row { display: flex; gap: 8px; }
    .row > button { flex: 1; }
    .status { font-size: 14px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    async function health() {
      const el = document.getElementById('health');
      try { const r = await fetch('/api/health'); const j = await r.json(); el.textContent = JSON.stringify(j); } catch (e) { el.textContent = e.message; }
    }
    async function addStream() {
      const uri = document.getElementById('streamUri').value;
      const payload = { stream_id: 'stream_0', uri, source_id: 0 };
      const r = await fetch('/api/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const j = await r.json(); document.getElementById('status').textContent = JSON.stringify(j);
    }
    async function removeStream() {
      const r = await fetch('/api/stream/stream_0', { method: 'DELETE' });
      const j = await r.json(); document.getElementById('status').textContent = JSON.stringify(j);
    }
    function playHls() {
      const url = document.getElementById('hlsUrl').value;
      const video = document.getElementById('video');
      const isM3U8 = url.toLowerCase().endsWith('.m3u8');
      if (isM3U8 && window.Hls && Hls.isSupported()) { const hls = new Hls(); hls.loadSource(url); hls.attachMedia(video); } else { video.src = url; }
      video.play();
    }
    async function updateInference() {
      const payload = {
        infer_name: document.getElementById('inferName').value || 'primary-detector',
        batch_size: Number(document.getElementById('batchSize').value || 1),
        interval: Number(document.getElementById('interval').value || 1),
        gpu_id: Number(document.getElementById('gpuId').value || 0)
      };
      try {
        const r = await fetch('/api/infer', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const j = await r.json(); document.getElementById('inferStatus').textContent = JSON.stringify(j);
      } catch (e) {
        document.getElementById('inferStatus').textContent = e.message;
      }
    }
    async function addROI() {
      const payload = {
        stream_id: document.getElementById('roiStreamId').value || 'stream_0',
        roi_id: document.getElementById('roiId').value || 'roi_0',
        left: Number(document.getElementById('roiLeft').value || 0),
        top: Number(document.getElementById('roiTop').value || 0),
        width: Number(document.getElementById('roiWidth').value || 100),
        height: Number(document.getElementById('roiHeight').value || 100)
      };
      try {
        const r = await fetch('/api/roi', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const j = await r.json(); document.getElementById('roiStatus').textContent = JSON.stringify(j);
      } catch (e) {
        document.getElementById('roiStatus').textContent = e.message;
      }
    }
    async function sendMessage() {
      const text = document.getElementById('msgText').value || '';
      try {
        const r = await fetch('/api/message', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) });
        const j = await r.json(); document.getElementById('msgStatus').textContent = JSON.stringify(j);
        await loadMessages();
      } catch (e) {
        document.getElementById('msgStatus').textContent = e.message;
      }
    }
    async function loadMessages() {
      try {
        const r = await fetch('/api/message');
        const j = await r.json();
        const lines = (j.messages || []).slice(-50).map(m => new Date(m.ts).toISOString() + ' ' + m.text).join('\n');
        document.getElementById('msgList').textContent = lines || '(no messages)';
      } catch (e) {
        document.getElementById('msgList').textContent = e.message;
      }
    }
    async function clearMessages() {
      try {
        const r = await fetch('/api/message', { method: 'DELETE' });
        const j = await r.json();
        document.getElementById('msgStatus').textContent = JSON.stringify(j);
        await loadMessages();
      } catch (e) {
        document.getElementById('msgStatus').textContent = e.message;
      }
    }
    async function localHealth() {
      try {
        const r = await fetch('/api/local-health');
        const j = await r.json();
        document.getElementById('localHealth').textContent = JSON.stringify(j);
      } catch (e) {
        document.getElementById('localHealth').textContent = e.message;
      }
    }
    function setSourceType(t) { const isFile = t === 'file'; const fp = document.getElementById('filePicker'); if (fp) fp.style.display = isFile ? '' : 'none'; const rFile = document.getElementById('srcTypeFile'); const rCam = document.getElementById('srcTypeCamera'); if (rFile && rCam) { rFile.checked = isFile; rCam.checked = !isFile; } }
    async function refreshInputMedia() { try { const r = await fetch('/api/media/list'); const j = await r.json(); const sel = document.getElementById('inputMediaList'); const q = (document.getElementById('inputMediaSearch').value||'').toLowerCase(); sel.innerHTML=''; (j.files||[]).filter(p => !q || p.toLowerCase().includes(q)).forEach(p => { const o=document.createElement('option'); o.value=p; o.textContent=p.replace('/media/',''); sel.appendChild(o); }); } catch (e) { document.getElementById('inputStatus').textContent = e.message; } }
    function selectInputMedia() { const sel=document.getElementById('inputMediaList'); const p=sel.value||''; document.getElementById('hlsUrl').value = p; }
    function deriveStreamId(uri) { let h=0; for (let i=0;i<uri.length;i++){ h=(h*31 + uri.charCodeAt(i))>>>0; } return 'stream_' + (h%10); }
    async function connectSource() { try { let uri = document.getElementById('hlsUrl').value || document.getElementById('streamUri').value || ''; if (!uri) { document.getElementById('inputStatus').textContent = 'No source'; return; } const id = deriveStreamId(uri); const payload = { stream_id: id, uri, source_id: 0 }; const r = await fetch('/api/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); const j = await r.json(); document.getElementById('inputStatus').textContent = 'Connected • ' + id; try { localStorage.setItem('currentSourceUri', uri); localStorage.setItem('currentStreamId', id); localStorage.setItem('sourceType', uri.startsWith('/media/') ? 'file' : 'camera'); } catch {} } catch (e) { document.getElementById('inputStatus').textContent = e.message; } }
    async function disconnectSource() { try { const id = localStorage.getItem('currentStreamId') || 'stream_0'; const r = await fetch('/api/stream/' + encodeURIComponent(id), { method: 'DELETE' }); const j = await r.json(); document.getElementById('inputStatus').textContent = 'Disconnected • ' + id; } catch (e) { document.getElementById('inputStatus').textContent = e.message; } }
    function goToPipeline() { try { const uri = document.getElementById('hlsUrl').value || document.getElementById('streamUri').value || ''; const id = deriveStreamId(uri); localStorage.setItem('currentSourceUri', uri); localStorage.setItem('currentStreamId', id); localStorage.setItem('sourceType', uri.startsWith('/media/') ? 'file' : 'camera'); } catch {} setTab('pipeline'); try { const el = document.getElementById('iniPath'); if (el) el.scrollIntoView({ behavior:'smooth', block:'start' }); } catch{} }
    function setTab(name) {
      try {
        const nodes = document.querySelectorAll('[id^="tab-"]');
        nodes.forEach(el => { el.style.display = 'none'; });
        const target = document.getElementById('tab-' + name);
        const fallback = document.getElementById('tab-pipeline') ? 'pipeline' : 'input';
        const chosen = target ? name : fallback;
        const showEl = document.getElementById('tab-' + chosen);
        if (showEl) { showEl.style.display = 'grid'; }
        location.hash = '#' + chosen;
        try { toggleDsPythonMonitor(chosen === 'pipeline-python'); } catch {}
      } catch {}
    }
    function initTabs() { let t = (location.hash||'').replace('#',''); if (!t) t = 'input'; setTab(t); }
    window.addEventListener('load', () => { initTabs(); health(); loadMessages(); localHealth(); loadSamples(); });
    window.addEventListener('hashchange', initTabs);
    function toggleDsPythonMonitor(on) { try { if (window.dsPyMon) { clearInterval(window.dsPyMon); window.dsPyMon = null; } if (on) { updateDsPythonStatus(); window.dsPyMon = setInterval(updateDsPythonStatus, 2000); } } catch {} }
    async function updateDsPythonStatus() { try { const r = await fetch('/api/dspython/logs?tail=2000'); const t = await r.text(); const stateEl = document.getElementById('pyBackendState'); if (!stateEl) return; if (!r.ok) { stateEl.textContent = 'Backend: stopped'; return; } const lines = t.split(/\r?\n/); const giOk = /GI_OK|python3-gi|gobject-introspection|gir1\.2-gstreamer-1\.0|gir1\.2-glib-2\.0/i.test(t); const pydsOk = /PYDS_OK|import\s+pyds\s+.*succeeded|pyds\s+built|Building\s+wheel\s+for\s+pyds|deepstream_python_apps/i.test(t); const cudaOk = /CUDA_PY_OK|nvinfer|libcuda|cuInit|cuda/i.test(t); const readyOk = /DONE\s*1|RTSP.*8554|ready/i.test(t); const installing = /apt-get|\bGet:\b|Setting up|Unpacking|Reading package lists/i.test(t); const building = /cmake|make\b|ninja\b|pip\s+install\s+pyds|build/i.test(t); const hasError = /(error|failed|No module named pyds|ImportError)/i.test(t); let phase = 'setup'; if (hasError) phase = 'error'; else if (readyOk) phase = 'ready'; else if (building) phase = 'building'; else if (installing) phase = 'installing'; const parts = []; parts.push('Backend: running'); parts.push(giOk ? 'GI' : 'no GI'); parts.push(pydsOk ? 'pyds' : 'no pyds'); parts.push(cudaOk ? 'cuda' : 'no cuda'); parts.push('phase:' + phase); stateEl.textContent = parts.join(' • '); const focus = /(GI_|PYDS_|CUDA_|DONE|python3-gi|gobject-introspection|pyds|cmake|make|ninja|DeepStream|nvinfer|cuda|error|failed|Setting up|Unpacking|\bGet:\b|Reading package lists)/i; const filtered = lines.filter(l => focus.test(l)).slice(-80); const logEl = document.getElementById('pyRtspStatus'); if (logEl) logEl.textContent = (filtered.length ? filtered : lines.slice(-80)).join('\n'); } catch (e) { const el = document.getElementById('pyBackendState'); if (el) el.textContent = String(e); } }
    async function startDsPythonExample() { try { const r = await fetch('/api/dspython/start_example', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) }); const j = await r.json(); document.getElementById('pyExampleBackendStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('pyExampleBackendStatus').textContent = e.message; } }
    async function stopDsPythonExample() { try { const r = await fetch('/api/dspython/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('pyExampleBackendStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('pyExampleBackendStatus').textContent = e.message; } }
    async function logsDsPythonExample() { try { const r = await fetch('/api/dspython/logs?tail=1200'); const t = await r.text(); document.getElementById('pyExampleBackendStatus').textContent = t; } catch (e) { document.getElementById('pyExampleBackendStatus').textContent = e.message; } }
    async function runDsPythonExample() { try { const input = document.getElementById('pyExampleInput').value || '/opt/nvidia/deepstream/deepstream-6.0/samples/streams/sample_720p.h264'; const r = await fetch('/api/dspython/run_example', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ input, codec: 'H264' }) }); const j = await r.json(); document.getElementById('pyExampleRunStatus').textContent = JSON.stringify(j); try { if (j && j.rtsp) { localStorage.setItem('pyExampleRtsp', j.rtsp); } } catch {} } catch (e) { document.getElementById('pyExampleRunStatus').textContent = e.message; } }
    function playHlsExample() { const url = document.getElementById('pyExamplePlaylist').value || '/video/out.m3u8'; const video = document.getElementById('pyExampleVideo'); const isM3U8 = url.toLowerCase().endsWith('.m3u8'); if (isM3U8 && window.Hls && Hls.isSupported()) { const h = new Hls(); h.loadSource(url); h.attachMedia(video); } else { video.src = url; } video.play(); }
    async function startHlsExample() { try { let rtsp = ''; try { rtsp = localStorage.getItem('pyExampleRtsp') || ''; } catch {} if (!rtsp) { const host = location.hostname || '127.0.0.1'; rtsp = 'rtsp://' + host + ':8554/ds-stream'; } const r = await fetch('/api/hls/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uri: rtsp, hls_time: 2, hls_list_size: 5 }) }); const j = await r.json(); document.getElementById('pyExampleHlsStatus').textContent = JSON.stringify(j); if (j.playlist) { document.getElementById('pyExamplePlaylist').value = j.playlist; for (let i=0;i<20;i++){ try { const resp = await fetch(j.playlist, { cache: 'no-store' }); if (resp.ok){ playHlsExample(); break; } } catch{} await new Promise(res => setTimeout(res, 500)); } } } catch (e) { document.getElementById('pyExampleHlsStatus').textContent = e.message; } }
    async function stopHlsExample() { try { const r = await fetch('/api/hls/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('pyExampleHlsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('pyExampleHlsStatus').textContent = e.message; } }
    async function logsHlsExample() { try { const r = await fetch('/api/hls/logs'); const t = await r.text(); document.getElementById('pyExampleHlsStatus').textContent = t; } catch (e) { document.getElementById('pyExampleHlsStatus').textContent = e.message; } }
    async function clearHlsExample() { try { const r = await fetch('/api/hls/clear', { method: 'POST' }); const j = await r.json(); document.getElementById('pyExampleHlsStatus').textContent = JSON.stringify(j); try { const v = document.getElementById('pyExampleVideo'); v.removeAttribute('src'); } catch {} } catch (e) { document.getElementById('pyExampleHlsStatus').textContent = e.message; } }
  </script>
  </head>
<body>
  <div class="row" id="tabbar">
    <button onclick="setTab('input')">Input</button>
    <button onclick="setTab('pipeline')">Process Pipeline</button>
    <button onclick="setTab('pipeline-python')">Process Pipeline Python</button>
    <button onclick="setTab('testing-python')">Testing Python Example</button>
    <button onclick="setTab('output')">Output</button>
    <button onclick="setTab('utility')">Utility</button>
  </div>
  <div class="grid" id="tab-output" style="display:none">
    <div class="card">
      <h2>HLS Output</h2>
      <input id="hlsPlayUrl" placeholder="/video/out.m3u8" value="/video/out.m3u8" />
      <div class="row">
        <button onclick="playHlsOut()">Play</button>
      </div>
      <video id="videoOut" playsinline controls muted></video>
      <div class="row">
        <input id="hlsTime" type="number" placeholder="segment seconds" value="2" />
        <input id="hlsListSize" type="number" placeholder="list size" value="5" />
        <button onclick="startHlsWithParams()">Start HLS</button>
        <button onclick="stopHls()">Stop</button>
        <button onclick="logsHlsOut()">Logs</button>
        <button id="btnClearHlsOut" onclick="clearHlsOut()">Clear Segments</button>
      </div>
      <div class="status" id="hlsOutStatus"></div>
    </div>
    <div class="card">
      <h2>RTSP Server</h2>
      <div class="row">
        <button onclick="startRtsp()">Start RTSP Server</button>
        <button onclick="stopRtsp()">Stop</button>
        <button onclick="logsRtsp()">Logs</button>
      </div>
      <div class="status" id="rtspStatus"></div>
      <div class="status">Default: rtsp://127.0.0.1:8554/ds-test</div>
    </div>
    <div class="card">
      <h2>Python RTSP Out</h2>
      <input id="pythonRtspUrl" placeholder="rtsp://host:8554/ds-stream" />
      <div class="row">
        <button onclick="copyPythonRtspUrl()">Copy URL</button>
      </div>
      <div class="status" id="pythonRtspStatus"></div>
    </div>
    <div class="card">
      <h2>JSON Output</h2>
      <div class="row">
        <button onclick="refreshJsonLogs()">Refresh</button>
      </div>
      <div class="status" id="jsonLogs" style="white-space:pre-wrap"></div>
    </div>
  </div>
  <div class="grid" id="tab-input">
    <div class="card">
      <h2>Video</h2>
      <input id="hlsUrl" placeholder="/video/stream.m3u8 or /media/bird.mp4" value="rtsp://127.0.0.1:8554/ds-test" />
      <div class="row">
        <button onclick="playHls()">Play</button>
        <button onclick="startHls()">Start HLS</button>
        <button onclick="stopHls()">Stop HLS</button>
        <button onclick="logsHls()">Logs</button>
        <button id="btnClearHls" onclick="clearHls()">Clear Segments</button>
      </div>
      <div class="row" style="align-items:center">
        <label style="flex:1"><input type="radio" name="srcType" id="srcTypeCamera" checked onchange="setSourceType('camera')" /> Camera</label>
        <label style="flex:1"><input type="radio" name="srcType" id="srcTypeFile" onchange="setSourceType('file')" /> File</label>
      </div>
      <div id="filePicker" style="display:none">
        <input id="inputMediaSearch" placeholder="search" />
        <select id="inputMediaList" size="6" style="width:100%" onchange="selectInputMedia()"></select>
        <div class="row">
          <button onclick="refreshInputMedia()">Refresh Media</button>
        </div>
      </div>
      <div class="row">
        <button onclick="connectSource()">Connect</button>
        <button onclick="disconnectSource()">Disconnect</button>
        <button onclick="goToPipeline()">Go to Pipeline</button>
      </div>
      <div class="status" id="inputStatus"></div>
      <video id="video" playsinline controls muted></video>
      <div class="status" id="hlsStatus"></div>
    </div>
    <div class="card">
      <h2>Control</h2>
      <input id="streamUri" placeholder="rtsp://camera-ip/stream" />
      <div class="row">
        <button onclick="addStream()">Add Stream</button>
        <button onclick="removeStream()">Remove Stream</button>
      </div>
      <div class="status" id="status"></div>
      <h3>Health</h3>
      <div class="status" id="health"></div>
    </div>
  </div>
  <div class="grid" id="tab-pipeline" style="display:none">
    <div class="card">
      <h2>Inference</h2>
      <input id="inferName" placeholder="primary-detector" />
      <input id="batchSize" type="number" placeholder="batch size" />
      <input id="interval" type="number" placeholder="interval" />
      <input id="gpuId" type="number" placeholder="gpu id" />
      <div class="row">
        <button onclick="updateInference()">Update Inference</button>
      </div>
      <div class="status" id="inferStatus"></div>
    </div>
    <div class="card">
      <h2>ROI</h2>
      <input id="roiStreamId" placeholder="stream_0" />
      <input id="roiId" placeholder="roi_0" />
      <input id="roiLeft" type="number" placeholder="left" />
      <input id="roiTop" type="number" placeholder="top" />
      <input id="roiWidth" type="number" placeholder="width" />
      <input id="roiHeight" type="number" placeholder="height" />
      <div class="row">
        <button onclick="addROI()">Add/Update ROI</button>
      </div>
      <div class="status" id="roiStatus"></div>
    </div>
    <div class="card">
      <h2>DeepStream Samples</h2>
      <select id="dsSample"></select>
      <select id="dsIniList" size="6" style="width:100%" onchange="selectDsIniFromList()"></select>
      <textarea id="dsUris" rows="3" placeholder="Optional file paths. For Custom INI, put absolute /app/configs/... on first line"></textarea>
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="dsAutoEngine" /> Auto-build engine (remove model-engine-file)</label>
      <input id="dsImage" placeholder="Optional image override (e.g., siridech/deepstream-l4t:6.0.1-triton-prebuilt)" />
      <div class="row">
        <button onclick="loadSamples()">List</button>
        <button onclick="listDsIni()">List INIs</button>
        <button onclick="startDsApp()">Run</button>
        <button onclick="stopDsApp()">Stop</button>
        <button onclick="logsDsApp()">Logs</button>
        <button onclick="startAutoDsLogs()">Auto Start</button>
        <button onclick="stopAutoDsLogs()">Auto Stop</button>
      </div>
      <div class="row">
        <button onclick="runDsPythonRtsp()">Run Python RTSP Out</button>
        <button onclick="stopDsPythonRtsp()">Stop Python</button>
        <button onclick="logsDsPythonRtsp()">Python Logs</button>
      </div>
      <div class="status" id="dsStatus"></div>
      <div class="row">
        <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="dsLogsFilter" /> Filter important</label>
        <input id="dsLogsQuery" placeholder="Search text" />
        <button onclick="searchDsLogs()">Search</button>
      </div>
      <div class="status" id="dsLogs" style="white-space:pre-wrap"></div>
    </div>
    <div class="card">
      <h2>INI Editor</h2>
      <input id="iniPath" placeholder="/app/configs/source1_fp16.ini" />
      <textarea id="iniText" rows="12" style="width:100%;height:240px" placeholder="Paste INI content here"></textarea>
      <select id="iniList" size="6" style="width:100%" onchange="selectIniFromList()"></select>
      <div class="row">
        <label style="flex:1">Text size <input id="osdTextSize" type="range" min="10" max="48" value="26" /></label>
        <label style="flex:1">BG opacity <input id="osdBgOpacity" type="range" min="0" max="255" value="160" /></label>
        <label style="flex:1">Confidence <input id="osdThreshold" type="number" step="0.05" min="0" max="1" value="0.5" /></label>
        <label style="flex:1">Text color <input id="osdTextColor" type="color" value="#ffffff" /></label>
        <label style="flex:1">Text alpha <input id="osdTextAlpha" type="range" min="0" max="255" value="255" /></label>
      </div>
      <div class="row">
        <button onclick="listIni()">List</button>
        <button onclick="loadIni()">Load</button>
        <button onclick="saveIni()">Save</button>
        <button onclick="runIni()">Run</button>
        <button onclick="patchIniLabels()">Patch Labels</button>
        <button onclick="patchOsdSettings()">Apply OSD</button>
        <button onclick="patchSinkRtsp()">Apply RTSP Sink</button>
        <button onclick="bindSourceToIni()">Bind Source to INI</button>
        <button onclick="finalizeConfig()">Finalize Configuration</button>
      </div>
      <div class="status" id="iniStatus"></div>
      <h3>Rendered INI</h3>
      <textarea id="iniPreview" rows="10" style="width:100%;height:200px" readonly></textarea>
      <h3>Rendered PGIE</h3>
      <input id="pgiePath" placeholder="/app/configs/pgie_resnet10.txt" />
      <textarea id="pgiePreview" rows="10" style="width:100%;height:200px" placeholder="Edit PGIE config"></textarea>
      <select id="pgieList" size="6" style="width:100%" onchange="selectPgieFromList()"></select>
      <div class="row">
        <button onclick="listPgie()">List PGIEs</button>
        <button onclick="loadPgie()">Load PGIE</button>
        <button onclick="savePgie()">Save PGIE</button>
      </div>
      <div class="status" id="pgieStatus"></div>
    </div>
    <div class="card">
      <h2>Labels</h2>
      <input id="labelsPath" placeholder="/app/configs/labels.txt" />
      <textarea id="labelsText" rows="10" style="width:100%;height:200px" placeholder="One label per line"></textarea>
      <select id="labelsList" size="6" style="width:100%" onchange="selectLabelsFromList()"></select>
      <div class="row">
        <button onclick="listLabels()">List Labels</button>
        <button onclick="loadLabels()">Load</button>
        <button onclick="saveLabels()">Save</button>
      </div>
      <div class="status" id="labelsStatus"></div>
    </div>
  </div>
  <div class="grid" id="tab-pipeline-python" style="display:none">
    <div class="card">
      <h2>DeepStream Python RTSP-out</h2>
      <input id="pySrcUri" placeholder="rtsp://... or /media/file.mp4" />
      <div class="row">
        <button onclick="useInputSourceForPy()">Use Input Source</button>
      </div>
      <div class="row">
        <button onclick="runDsPythonRtsp()">Run</button>
        <button onclick="stopDsPythonRtsp()">Stop</button>
        <button onclick="logsDsPythonRtsp()">Logs</button>
      </div>
      <div class="row">
        <button onclick="startDsPythonBackend()">Start Backend</button>
        <button onclick="provisionDsPythonBackend()">Provision Backend (install)</button>
        <button onclick="stopDsPythonBackend()">Stop Backend</button>
        <button onclick="logsDsPythonBackend()">Backend Logs</button>
      </div>
      <div class="status" id="pyBackendState"></div>
      <div class="status" id="pyRtspStatus" style="white-space:pre-wrap"></div>
    </div>
  </div>
  <div class="grid" id="tab-testing-python" style="display:none">
    <div class="card">
      <h2>Backend</h2>
      <div class="row">
        <button onclick="startDsPythonExample()">Start Backend (Example)</button>
        <button onclick="stopDsPythonExample()">Stop Backend</button>
        <button onclick="logsDsPythonExample()">Backend Logs</button>
      </div>
      <div class="status" id="pyExampleBackendStatus"></div>
    </div>
    <div class="card">
      <h2>Run Python Example</h2>
      <input id="pyExampleInput" placeholder="/opt/.../sample_720p.h264" value="/opt/nvidia/deepstream/deepstream-6.0/samples/streams/sample_720p.h264" />
      <div class="row">
        <button onclick="runDsPythonExample()">Run Example</button>
      </div>
      <div class="status" id="pyExampleRunStatus"></div>
    </div>
    <div class="card">
      <h2>Preview</h2>
      <div class="row">
        <button onclick="startHlsExample()">Start Preview</button>
        <button onclick="stopHlsExample()">Stop Preview</button>
        <button onclick="logsHlsExample()">Preview Logs</button>
        <button onclick="clearHlsExample()">Clear Segments</button>
      </div>
      <input id="pyExamplePlaylist" placeholder="/video/out.m3u8" value="/video/out.m3u8" />
      <div class="row">
        <button onclick="playHlsExample()">Play</button>
      </div>
      <video id="pyExampleVideo" playsinline controls muted></video>
      <div class="status" id="pyExampleHlsStatus"></div>
    </div>
  </div>
  <div class="grid" id="tab-utility" style="display:none">
    <div class="card">
      <h2>Messages</h2>
      <textarea id="msgText" rows="8" style="width:100%;height:160px" placeholder="Type a message to send"></textarea>
      <div class="row">
        <button onclick="sendMessage()">Send</button>
        <button onclick="loadMessages()">Refresh</button>
        <button onclick="clearMsgText()">Clear Text</button>
        <button onclick="clearMessages()">Clear</button>
      </div>
      <div class="status" id="msgStatus"></div>
      <div class="status" id="msgList" style="white-space:pre-wrap"></div>
    </div>
    <div class="card">
      <h2>Snapshot</h2>
      <input id="snapUri" placeholder="rtsp://... or /data/videos/file.mp4" />
      <input id="snapRate" type="number" placeholder="rate per second" />
      <select id="mediaList" size="6" style="width:100%" onchange="selectMediaFile()"></select>
      <div class="row">
        <button onclick="listMedia()">List Media</button>
        <button onclick="useVideoForSnap()">Use Video</button>
        <button onclick="startSnap()">Start</button>
        <button onclick="stopSnap()">Stop</button>
        <button onclick="clearSnap()">Clear Images</button>
        <button onclick="loadSnapLogs()">Logs</button>
      </div>
      <div class="status" id="snapStatus"></div>
      <div class="status" id="snapCount"></div>
      <div id="snapViewer" style="display:flex;flex-direction:column;gap:8px;align-items:center;">
        <img id="snapImage" style="max-width:100%;height:auto;object-fit:contain" />
        <div class="row" style="width:100%">
          <button onclick="prevSnap()">Prev</button>
          <div id="snapIndex" class="status" style="text-align:center"></div>
          <button onclick="nextSnap()">Next</button>
        </div>
      </div>
    </div>
    <div class="card">
      <h2>System Health</h2>
      <div class="row">
        <button onclick="localHealth()">Refresh</button>
      </div>
      <div class="status" id="localHealth"></div>
    </div>
    <div class="card">
      <h2>Admin</h2>
      <div class="row">
        <button onclick="loadAdminEnv()">Env</button>
        <button onclick="loadAdminContainers()">Containers</button>
      </div>
      <div class="status" id="adminEnv"></div>
      <div class="status" id="adminContainers"></div>
    </div>
  </div>
  <script>
    async function startSnap() {
      let uri = document.getElementById('snapUri').value || '';
      if (!uri) { uri = document.getElementById('hlsUrl').value || ''; }
      const rate = Number(document.getElementById('snapRate').value || 1);
      try {
        const r = await fetch('/api/snapshot/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uri, rate }) });
        const j = await r.json(); document.getElementById('snapStatus').textContent = JSON.stringify(j);
        try { const c = (typeof j.count === 'number') ? j.count : 0; document.getElementById('snapCount').textContent = 'Images: ' + c; } catch {}
        await loadSnapImages(false);
        if (window.snapTimer) clearInterval(window.snapTimer);
        window.snapTimer = setInterval(async () => { await loadSnapImages(false); await localHealth(); }, 3000);
      } catch (e) {
        document.getElementById('snapStatus').textContent = e.message;
      }
    }
    function useVideoForSnap() {
      const url = document.getElementById('hlsUrl').value || '';
      document.getElementById('snapUri').value = url;
    }
    async function stopSnap() {
      try {
        const r = await fetch('/api/snapshot/stop', { method: 'POST' });
        const j = await r.json(); document.getElementById('snapStatus').textContent = JSON.stringify(j);
        await loadSnapImages(true);
        if (window.snapTimer) { clearInterval(window.snapTimer); window.snapTimer = null; }
      } catch (e) {
        document.getElementById('snapStatus').textContent = e.message;
      }
    }
    async function loadSnapLogs() {
      try {
        const r = await fetch('/api/snapshot/logs');
        const t = await r.text();
        document.getElementById('snapStatus').textContent = t;
      } catch (e) { document.getElementById('snapStatus').textContent = e.message; }
    }
    async function clearSnap() {
      try {
        const r = await fetch('/api/snapshot/clear', { method: 'DELETE' });
        const j = await r.json();
        document.getElementById('snapStatus').textContent = JSON.stringify(j);
        window.snapFiles = [];
        window.snapIndex = 0;
        try { document.getElementById('snapCount').textContent = 'Images: 0'; } catch {}
        renderSnap();
        await loadSnapImages(true);
      } catch (e) {
        document.getElementById('snapStatus').textContent = e.message;
      }
    }
    async function listMedia() { try { const r = await fetch('/api/media/list'); const j = await r.json(); const sel = document.getElementById('mediaList'); sel.innerHTML=''; if (j && Array.isArray(j.files)) { (j.files||[]).forEach(p => { const o=document.createElement('option'); o.value=p; o.textContent=p.replace('/media/',''); sel.appendChild(o); }); } else { document.getElementById('snapStatus').textContent = (j && j.error) ? j.error : 'No media found'; } } catch (e) { document.getElementById('snapStatus').textContent = e.message; } }
    function selectMediaFile() { const sel=document.getElementById('mediaList'); const p=sel.value||''; document.getElementById('snapUri').value = p; }
    async function loadSnapImages(limitAll) {
      try {
        const r = await fetch('/api/snapshot/list' + (limitAll ? '?limit=100000' : ''));
        const j = await r.json();
        const files = j.files || [];
        const prevLen = (window.snapFiles && window.snapFiles.length) || 0;
        window.snapFiles = files;
        try { document.getElementById('snapCount').textContent = 'Images: ' + files.length; } catch {}
        if (files.length === 0) { window.snapIndex = 0; renderSnap(); return; }
        if (prevLen === 0) { window.snapIndex = files.length - 1; } else { if (window.snapIndex >= files.length) window.snapIndex = files.length - 1; }
        renderSnap();
      } catch (e) {}
    }
    function renderSnap() {
      const imgEl = document.getElementById('snapImage');
      const idxEl = document.getElementById('snapIndex');
      const files = window.snapFiles || [];
      if (!files.length) { imgEl.removeAttribute('src'); idxEl.textContent = '(no images)'; return; }
      const i = Math.max(0, Math.min(window.snapIndex || 0, files.length - 1));
      window.snapIndex = i;
      imgEl.src = '/snapshots/' + files[i];
      idxEl.textContent = (i + 1) + '/' + files.length;
    }
    function prevSnap() { const n = (window.snapFiles || []).length; if (!n) return; window.snapIndex = (window.snapIndex + n - 1) % n; renderSnap(); }
    function nextSnap() { const n = (window.snapFiles || []).length; if (!n) return; window.snapIndex = (window.snapIndex + 1) % n; renderSnap(); }
    function clearMsgText() { document.getElementById('msgText').value = ''; }
    async function loadSamples() { try { const r = await fetch('/api/dsapp/samples'); const j = await r.json(); const sel = document.getElementById('dsSample'); sel.innerHTML = ''; (j.samples||[]).forEach(s => { const o = document.createElement('option'); o.value = s.id; o.textContent = s.label; sel.appendChild(o); }); } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    async function startDsApp() { const sample = document.getElementById('dsSample').value || 'test1'; const image = document.getElementById('dsImage').value || ''; const text = document.getElementById('dsUris').value || ''; const uris = text.split('\n').map(s => s.trim()).filter(Boolean); const autoEngine = !!document.getElementById('dsAutoEngine').checked; try { const r = await fetch('/api/dsapp/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sample, uris, image, autoEngine }) }); const j = await r.json(); document.getElementById('dsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    async function stopDsApp() { try { const r = await fetch('/api/dsapp/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('dsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    async function logsDsApp() { try { const r = await fetch('/api/dsapp/logs'); const t = await r.text(); const f = document.getElementById('dsLogsFilter'); if (f && f.checked) { const lines = t.split(/\r?\n/); const re = /(NvDsInfer|nvinfer|ERROR|PLAYING|pipeline)/i; document.getElementById('dsLogs').textContent = lines.filter(l => re.test(l)).join('\n'); } else { document.getElementById('dsLogs').textContent = t; } } catch (e) { document.getElementById('dsLogs').textContent = e.message; } }
    async function searchDsLogs() { try { const q = document.getElementById('dsLogsQuery').value || ''; if (!q) { return logsDsApp(); } const r = await fetch('/api/dsapp/logs/search?q=' + encodeURIComponent(q) + '&tail=1200'); const t = await r.text(); document.getElementById('dsLogs').textContent = t; } catch (e) { document.getElementById('dsLogs').textContent = e.message; } }
    function startAutoDsLogs() { try { if (window.dsLogsTimer) { clearInterval(window.dsLogsTimer); } window.dsLogsTimer = setInterval(logsDsApp, 1000); } catch {} }
    function stopAutoDsLogs() { try { if (window.dsLogsTimer) { clearInterval(window.dsLogsTimer); window.dsLogsTimer = null; } } catch {} }
    async function loadIni() { try { const p = document.getElementById('iniPath').value || ''; const r = await fetch('/api/configs/read?path=' + encodeURIComponent(p)); const j = await r.json(); if (j.content !== undefined) { document.getElementById('iniText').value = j.content; document.getElementById('iniStatus').textContent = 'Loaded'; } else { document.getElementById('iniStatus').textContent = JSON.stringify(j); } } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    async function saveIni() { try { const p = document.getElementById('iniPath').value || ''; const content = document.getElementById('iniText').value || ''; const r = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: p, content }) }); const j = await r.json(); document.getElementById('iniStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    async function listIni() { try { const r = await fetch('/api/configs/list?dir=' + encodeURIComponent('/app/configs/')); const j = await r.json(); const sel = document.getElementById('iniList'); sel.innerHTML = ''; if (j && Array.isArray(j.files)) { const prefix = (j && j.dir) || '/app/configs/'; (j.files||[]).forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p.startsWith(prefix) ? p.slice(prefix.length) : p.replace('/app/configs/',''); sel.appendChild(o); }); document.getElementById('iniStatus').textContent = 'Found ' + (j.files||[]).length + ' INIs'; } else { document.getElementById('iniStatus').textContent = (j && j.error) ? j.error : 'No INIs found'; } } catch (e) { document.getElementById('iniStatus').textContent = e.message; } }
    function selectIniFromList() { const sel = document.getElementById('iniList'); const p = sel.value || ''; document.getElementById('iniPath').value = p; loadIni(); }
    async function runIni() {
      const p = document.getElementById('iniPath').value || '';
      const image = document.getElementById('dsImage').value || '';
      const autoEngine = !!document.getElementById('dsAutoEngine').checked;
      try {
        let r = await fetch('/api/dsapp/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sample: 'app_custom_ini', uris: [p], image, autoEngine }) });
        let j = await r.json();
        if (j && j.error === 'playlist-missing') {
          try {
            await startHls();
            for (let i = 0; i < 20; i++) {
              try { const resp = await fetch('/video/out.m3u8', { cache: 'no-store' }); if (resp.ok) break; } catch {}
              await new Promise(res => setTimeout(res, 500));
            }
            r = await fetch('/api/dsapp/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sample: 'app_custom_ini', uris: [p], image, autoEngine }) });
            j = await r.json();
          } catch {}
        }
        document.getElementById('iniStatus').textContent = JSON.stringify(j);
      } catch (e) { document.getElementById('iniStatus').textContent = e.message; }
    }
    function bindSourceToIni() {
      const src = (document.getElementById('hlsUrl').value || document.getElementById('streamUri').value || '').trim();
      if (!src) { document.getElementById('iniStatus').textContent = 'No source selected'; return; }
      let txt = document.getElementById('iniText').value || '';
      const isRtsp = /^rtsp:\/\//i.test(src);
      let uriVal = src;
      if (isRtsp) {
        uriVal = src;
      } else if (src.startsWith('/media/')) {
        uriVal = 'file:///data/videos/' + src.slice(7);
      } else if (src.startsWith('/video/')) {
        uriVal = 'file:///app/public/video/' + src.slice(7);
      } else if (src.startsWith('/')) {
        uriVal = 'file://' + src;
      }
      let lines = txt.split(/\r?\n/);
      let patched = [];
      let inSrc0 = false, sawSrc0 = false, sawEnable = false, sawType = false, sawUri = false;
      let srcHeaderIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        const s = l.trim();
        if (s.startsWith('[') && s.endsWith(']')) {
          inSrc0 = /\[\s*source0\s*\]/i.test(s);
          if (inSrc0) { sawSrc0 = true; srcHeaderIndex = patched.length; }
          patched.push(l);
          continue;
        }
        if (inSrc0) {
          if (/^\s*enable\s*=\s*/i.test(s)) { patched.push('enable=1'); sawEnable = true; continue; }
          if (/^\s*type\s*=\s*/i.test(s)) { patched.push('type=3'); sawType = true; continue; }
          if (/^\s*uri\s*=\s*/i.test(s)) { patched.push('uri=' + uriVal); sawUri = true; continue; }
        }
        patched.push(l);
      }
      if (!sawSrc0) { patched.push('[source0]'); srcHeaderIndex = patched.length - 1; }
      const toInsert = [];
      if (!sawEnable) toInsert.push('enable=1');
      if (!sawType) toInsert.push('type=3');
      if (!sawUri) toInsert.push('uri=' + uriVal);
      if (toInsert.length) { const insertAt = srcHeaderIndex + 1; patched = patched.slice(0, insertAt).concat(toInsert).concat(patched.slice(insertAt)); }
      document.getElementById('iniText').value = patched.join('\n');
      document.getElementById('iniStatus').textContent = 'Source bound: ' + uriVal;
    }
    async function finalizeConfig() {
      try {
        const p = document.getElementById('iniPath').value || '/app/configs/source1_fp16.ini';
        let content = document.getElementById('iniText').value || '';
        try {
          let lines = content.split(/\r?\n/);
          let patched = [];
          let inMux = false, sawMux = false;
          let sawWidth = false, sawHeight = false, sawBatch = false, sawLive = false;
          let muxHeaderIndex = -1;
          for (let i = 0; i < lines.length; i++) {
            const l = lines[i];
            const s = l.trim();
            if (s.startsWith('[') && s.endsWith(']')) {
              inMux = /\[\s*streammux\s*\]/i.test(s);
              if (inMux) { sawMux = true; muxHeaderIndex = patched.length; }
              patched.push(l);
              continue;
            }
            if (inMux) {
              if (/^\s*width\s*=\s*/i.test(s)) { patched.push('width=1280'); sawWidth = true; continue; }
              if (/^\s*height\s*=\s*/i.test(s)) { patched.push('height=720'); sawHeight = true; continue; }
              if (/^\s*batch-size\s*=\s*/i.test(s)) { patched.push('batch-size=1'); sawBatch = true; continue; }
              if (/^\s*live-source\s*=\s*/i.test(s)) { patched.push('live-source=1'); sawLive = true; continue; }
            }
            patched.push(l);
          }
          if (!sawMux) { patched.push('[streammux]'); muxHeaderIndex = patched.length - 1; }
          const toInsert = [];
          if (!sawWidth) toInsert.push('width=1280');
          if (!sawHeight) toInsert.push('height=720');
          if (!sawBatch) toInsert.push('batch-size=1');
          if (!sawLive) toInsert.push('live-source=1');
          if (toInsert.length) { const insertAt = muxHeaderIndex + 1; patched = patched.slice(0, insertAt).concat(toInsert).concat(patched.slice(insertAt)); }
          content = patched.join('\n');
          document.getElementById('iniText').value = content;
        } catch {}
        const saveR = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: p, content }) });
        const saveJ = await saveR.json();
        document.getElementById('iniStatus').textContent = JSON.stringify(saveJ);
        const r1 = await fetch('/api/configs/read?path=' + encodeURIComponent(p));
        const j1 = await r1.json();
        if (j1.content !== undefined) { document.getElementById('iniPreview').value = j1.content; }
        let pgie = '';
        try {
          const pp = document.getElementById('pgiePath').value || '/app/configs/pgie_resnet10.txt';
          const r2 = await fetch('/api/configs/read?path=' + encodeURIComponent(pp));
          const j2 = await r2.json();
          if (j2.content !== undefined) { document.getElementById('pgiePreview').value = j2.content; document.getElementById('pgieStatus').textContent = 'Loaded'; }
        } catch {}
      } catch (e) { document.getElementById('iniStatus').textContent = e.message; }
    }
    async function startHls() {
      let uri = document.getElementById('streamUri').value || '';
      if (!uri) { uri = document.getElementById('hlsUrl').value || ''; }
      try {
        const r = await fetch('/api/hls/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uri, hls_time: Number(document.getElementById('hlsTime') ? document.getElementById('hlsTime').value : 2), hls_list_size: Number(document.getElementById('hlsListSize') ? document.getElementById('hlsListSize').value : 5) }) });
        const j = await r.json();
        document.getElementById('hlsStatus').textContent = JSON.stringify(j);
        if (j.playlist) {
          document.getElementById('hlsUrl').value = j.playlist;
          for (let i = 0; i < 20; i++) {
            try {
              const resp = await fetch(j.playlist, { cache: 'no-store' });
              if (resp.ok) { playHls(); break; }
            } catch {}
            await new Promise(res => setTimeout(res, 500));
          }
        }
      } catch (e) { document.getElementById('hlsStatus').textContent = e.message; }
    }
    function playHlsOut() { const url = document.getElementById('hlsPlayUrl').value || '/video/out.m3u8'; const video = document.getElementById('videoOut'); const isM3U8 = url.toLowerCase().endsWith('.m3u8'); if (isM3U8 && window.Hls && Hls.isSupported()) { const h = new Hls(); h.loadSource(url); h.attachMedia(video); } else { video.src = url; } video.play(); }
    async function startHlsWithParams() { try { const url = document.getElementById('hlsUrl').value || ''; const time = Number(document.getElementById('hlsTime').value || 2); const size = Number(document.getElementById('hlsListSize').value || 5); const r = await fetch('/api/hls/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uri: url, hls_time: time, hls_list_size: size }) }); const j = await r.json(); document.getElementById('hlsOutStatus').textContent = JSON.stringify(j); if (j.playlist) { document.getElementById('hlsPlayUrl').value = j.playlist; for (let i=0;i<20;i++){ try { const resp = await fetch(j.playlist, { cache: 'no-store' }); if (resp.ok){ playHlsOut(); break; } } catch{} await new Promise(res => setTimeout(res, 500)); } } } catch (e) { document.getElementById('hlsOutStatus').textContent = e.message; } }
    async function logsHlsOut() { try { const r = await fetch('/api/hls/logs'); const t = await r.text(); document.getElementById('hlsOutStatus').textContent = t; } catch (e) { document.getElementById('hlsOutStatus').textContent = e.message; } }
    async function startRtsp() { try { const r = await fetch('/api/rtsp/start', { method: 'POST' }); const j = await r.json(); document.getElementById('rtspStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('rtspStatus').textContent = e.message; } }
    async function stopRtsp() { try { const r = await fetch('/api/rtsp/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('rtspStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('rtspStatus').textContent = e.message; } }
    async function logsRtsp() { try { const r = await fetch('/api/rtsp/logs'); const t = await r.text(); document.getElementById('rtspStatus').textContent = t; } catch (e) { document.getElementById('rtspStatus').textContent = e.message; } }
    async function refreshJsonLogs() { try { const r = await fetch('/api/dsapp/logs'); const t = await r.text(); const lines = t.split(/\r?\n/).filter(x => /\{.*\}/.test(x)); document.getElementById('jsonLogs').textContent = lines.join('\n') || '(no json)'; } catch (e) { document.getElementById('jsonLogs').textContent = e.message; } }
    async function loadAdminEnv() { try { const r = await fetch('/api/admin/env'); const j = await r.json(); document.getElementById('adminEnv').textContent = JSON.stringify(j); } catch (e) { document.getElementById('adminEnv').textContent = e.message; } }
    async function loadAdminContainers() { try { const r = await fetch('/api/admin/containers'); const j = await r.json(); document.getElementById('adminContainers').textContent = JSON.stringify(j); } catch (e) { document.getElementById('adminContainers').textContent = e.message; } }
    function useInputSourceForPy() { const src = (document.getElementById('hlsUrl').value || document.getElementById('streamUri').value || '').trim(); const el = document.getElementById('pySrcUri'); if (el) el.value = src; }
    function toDsPyUri(src) { const s = (src||'').trim(); if (!s) return ''; if (/^rtsp:\/\//i.test(s)) return s; if (s.startsWith('/media/')) return 'file:///data/videos/' + s.slice(7); if (s.startsWith('/video/')) return 'file:///app/public/video/' + s.slice(7); if (s.startsWith('/')) return 'file://' + s; return s; }
    async function runDsPythonRtsp() { try { let src = document.getElementById('pySrcUri') && document.getElementById('pySrcUri').value ? document.getElementById('pySrcUri').value : (document.getElementById('hlsUrl').value || document.getElementById('streamUri').value || (localStorage.getItem('currentSourceUri')||'')); if (!src) { const sEl=document.getElementById('dsStatus'); if (sEl) sEl.textContent='No source'; const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent='No source'; return; } const uri = toDsPyUri(src); const cmd = [
        'RTSP_STOP=$(curl -s -X POST http://localhost:3000/api/rtsp/stop || true)',
        'DS_ROOT=$(ls -d /opt/nvidia/deepstream/deepstream-* | head -n 1)',
        'cd $DS_ROOT/sources/deepstream_python_apps/apps/deepstream-test1-rtsp-out',
        'pkill -f deepstream_test1_rtsp_out.py || true',
        `nohup python3 deepstream_test1_rtsp_out.py "${uri}" > /app/configs/ds_py_rtsp_out.txt 2>&1 & echo STARTED=$!`
      ].join(' && ');
      let r = await fetch('/api/dspython/exec', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ cmd, wait_ms: 1000 }) });
      let t = await r.text();
      let out = ''; try { out = atob(t.trim()); } catch { out = t; }
      if (!r.ok || /ds_python not running/i.test(out)) {
        try {
          const sr = await fetch('/api/dspython/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ install: false, useGit: false }) });
          await sr.text();
          await new Promise(res => setTimeout(res, 6000));
          r = await fetch('/api/dspython/exec', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ cmd, wait_ms: 1000 }) });
          t = await r.text();
          try { out = atob(t.trim()); } catch { out = t; }
        } catch (e) {
          const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = String(e);
        }
      }
      const host = location.hostname || '127.0.0.1'; const u = 'rtsp://' + host + ':8554/ds-stream';
      const sEl=document.getElementById('dsStatus'); if (sEl) sEl.textContent = (out || 'Started') + ' • ' + u; const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = (out || 'Started') + ' • ' + u; const fEl=document.getElementById('pythonRtspUrl'); if (fEl) fEl.value = u; const pStat=document.getElementById('pythonRtspStatus'); if (pStat) pStat.textContent = 'URL: ' + u;
    } catch (e) { document.getElementById('dsStatus').textContent = e.message; }
    }
    async function startDsPythonBackend() { try { const r = await fetch('/api/dspython/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ install: false, useGit: false }) }); const t = await r.text(); const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = t; } catch (e) { const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = e.message; } }
    async function provisionDsPythonBackend() { try { const r = await fetch('/api/dspython/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ install: true, useGit: true }) }); const t = await r.text(); const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = t; } catch (e) { const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = e.message; } }
    async function stopDsPythonBackend() { try { const r = await fetch('/api/dspython/stop', { method: 'POST' }); const j = await r.json(); const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = JSON.stringify(j); } catch (e) { const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = e.message; } }
    async function logsDsPythonBackend() { try { const r = await fetch('/api/dspython/logs'); const t = await r.text(); const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = t; } catch (e) { const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = e.message; } }
    async function stopDsPythonRtsp() { try { const r = await fetch('/api/dspython/exec', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ cmd: 'pkill -f deepstream_test1_rtsp_out.py || true; echo STOPPED', wait_ms: 500 }) }); const t = await r.text(); let out = ''; try { out = atob(t.trim()); } catch { out = t; } const sEl=document.getElementById('dsStatus'); if (sEl) sEl.textContent = out || 'Stopped'; const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = out || 'Stopped'; } catch (e) { const sEl=document.getElementById('dsStatus'); if (sEl) sEl.textContent = e.message; const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = e.message; } }
    async function logsDsPythonRtsp() { try { const r = await fetch('/api/dspython/exec', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ cmd: 'tail -n 200 /app/configs/ds_py_rtsp_out.txt || echo NO_LOG', wait_ms: 500 }) }); const t = await r.text(); let out = ''; try { out = atob(t.trim()); } catch { out = t; } const sEl=document.getElementById('dsStatus'); if (sEl) sEl.textContent = out; const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = out; const fEl=document.getElementById('pythonRtspUrl'); if (fEl) { const host = location.hostname || '127.0.0.1'; fEl.value = 'rtsp://' + host + ':8554/ds-stream'; } } catch (e) { const sEl=document.getElementById('dsStatus'); if (sEl) sEl.textContent = e.message; const pEl=document.getElementById('pyRtspStatus'); if (pEl) pEl.textContent = e.message; } }
    async function copyPythonRtspUrl() { try { const el = document.getElementById('pythonRtspUrl'); const v = el && el.value ? el.value : ''; if (!v) { const host = location.hostname || '127.0.0.1'; const u = 'rtsp://' + host + ':8554/ds-stream'; if (el) el.value = u; await navigator.clipboard.writeText(u); const pStat=document.getElementById('pythonRtspStatus'); if (pStat) pStat.textContent = 'Copied: ' + u; return; } await navigator.clipboard.writeText(v); const pStat=document.getElementById('pythonRtspStatus'); if (pStat) pStat.textContent = 'Copied: ' + v; } catch (e) { const pStat=document.getElementById('pythonRtspStatus'); if (pStat) pStat.textContent = e.message; } }
    async function stopHls() { try { const r = await fetch('/api/hls/stop', { method: 'POST' }); const j = await r.json(); document.getElementById('hlsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('hlsStatus').textContent = e.message; } }
    async function logsHls() { try { const r = await fetch('/api/hls/logs'); const t = await r.text(); document.getElementById('hlsStatus').textContent = t; } catch (e) { document.getElementById('hlsStatus').textContent = e.message; } }
    async function clearHls() { try { const r = await fetch('/api/hls/clear', { method: 'POST' }); const j = await r.json(); document.getElementById('hlsStatus').textContent = JSON.stringify(j); try { const v = document.getElementById('video'); v.removeAttribute('src'); } catch {} } catch (e) { document.getElementById('hlsStatus').textContent = e.message; } }
    async function clearHlsOut() { try { const r = await fetch('/api/hls/clear', { method: 'POST' }); const j = await r.json(); document.getElementById('hlsOutStatus').textContent = JSON.stringify(j); try { const v = document.getElementById('videoOut'); v.removeAttribute('src'); } catch {} } catch (e) { document.getElementById('hlsOutStatus').textContent = e.message; } }
    async function patchIniLabels() {
      const iniPath = document.getElementById('iniPath').value || '/app/configs/rtsp_osd.ini';
      let txt = document.getElementById('iniText').value || '';
      let lines = txt.split(/\r?\n/);
      let inPrimary = false, sawCfg = false, sawEnable = false, patched = [];
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        const s = l.trim();
        if (s.startsWith('[') && s.endsWith(']')) {
          if (inPrimary && !sawCfg) { const pPath = document.getElementById('pgiePath').value || '/opt/nvidia/deepstream/deepstream-6.0/samples/configs/deepstream-app/dstest1_pgie_config.txt'; patched.push('config-file=' + pPath); }
          inPrimary = /\[\s*primary-gie\s*\]/i.test(s);
          sawCfg = false;
          patched.push(l);
          continue;
        }
        if (inPrimary && /^\s*enable\s*=\s*/i.test(s)) { patched.push('enable=1'); sawEnable = true; continue; }
        if (inPrimary && /^\s*config-file\s*=\s*/i.test(s)) { const pPath = document.getElementById('pgiePath').value || '/opt/nvidia/deepstream/deepstream-6.0/samples/configs/deepstream-app/dstest1_pgie_config.txt'; patched.push('config-file=' + pPath); sawCfg = true; continue; }
        patched.push(l);
      }
      if (!/\[\s*primary-gie\s*\]/i.test('\n'+txt)) {
        patched.push('[primary-gie]');
        patched.push('enable=1');
        patched.push('config-file=' + (document.getElementById('pgiePath').value || '/opt/nvidia/deepstream/deepstream-6.0/samples/configs/deepstream-app/dstest1_pgie_config.txt'));
      } else {
        const insertAt = patched.findIndex(l => /\[\s*primary-gie\s*\]/i.test(l));
        const toInsert = [];
        if (!sawEnable) toInsert.push('enable=1');
        if (!sawCfg) toInsert.push('config-file=' + (document.getElementById('pgiePath').value || '/opt/nvidia/deepstream/deepstream-6.0/samples/configs/deepstream-app/dstest1_pgie_config.txt'));
        if (insertAt >= 0 && toInsert.length) {
          patched = patched.slice(0, insertAt + 1).concat(toInsert).concat(patched.slice(insertAt + 1));
        }
      }
      if (!/\[\s*osd\s*\]/i.test('\n'+txt)) {
        patched.push('[osd]');
        patched.push('enable=1');
        patched.push('display-text=1');
      } else {
        let osdLines = [];
        inPrimary = false; let inOsd = false; lines.forEach((l) => { const s=l.trim(); if (s.startsWith('[') && s.endsWith(']')) { inOsd = /\[\s*osd\s*\]/i.test(s); } });
      }
      const newTxt = patched.join('\n');
      document.getElementById('iniText').value = newTxt;
      try { document.getElementById('iniStatus').textContent = 'Primary GIE patched to sample config'; } catch {}
    }
    async function patchOsdSettings() {
      const textSize = Number(document.getElementById('osdTextSize').value || 26);
      const bgOpacity = Number(document.getElementById('osdBgOpacity').value || 160);
      const threshold = Number(document.getElementById('osdThreshold').value || 0.5);
      const colorHex = document.getElementById('osdTextColor').value || '#ffffff';
      const alpha = Number(document.getElementById('osdTextAlpha').value || 255);
      const r = parseInt(colorHex.slice(1,3),16), g = parseInt(colorHex.slice(3,5),16), b = parseInt(colorHex.slice(5,7),16);
      let txt = document.getElementById('iniText').value || '';
      let lines = txt.split(/\r?\n/);
      let patched = [];
      let inOsd = false;
      let sawOsd = false;
      let sawEnable = false, sawDisplay = false, sawTextSize = false, sawBg = false, sawColor = false;
      let osdHeaderIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        const s = l.trim();
        if (s.startsWith('[') && s.endsWith(']')) {
          inOsd = /\[\s*osd\s*\]/i.test(s);
          if (inOsd) { sawOsd = true; osdHeaderIndex = patched.length; }
          patched.push(l);
          continue;
        }
        if (inOsd) {
          if (/^\s*enable\s*=\s*/i.test(s)) { patched.push('enable=1'); sawEnable = true; continue; }
          if (/^\s*display-text\s*=\s*/i.test(s)) { patched.push('display-text=1'); sawDisplay = true; continue; }
          if (/^\s*text-size\s*=\s*/i.test(s)) { patched.push('text-size=' + textSize); sawTextSize = true; continue; }
          if (/^\s*text-bg-color\s*=\s*/i.test(s)) { patched.push(`text-bg-color=0;0;0;${bgOpacity}`); sawBg = true; continue; }
          if (/^\s*text-color\s*=\s*/i.test(s)) { patched.push(`text-color=${r};${g};${b};${alpha}`); sawColor = true; continue; }
        }
        patched.push(l);
      }
      if (!sawOsd) {
        patched.push('[osd]');
        patched.push('enable=1');
        patched.push('display-text=1');
        patched.push('text-size=' + textSize);
        patched.push('text-bg-color=0;0;0;' + bgOpacity);
        patched.push(`text-color=${r};${g};${b};${alpha}`);
      } else {
        const insertAt = osdHeaderIndex + 1;
        const toInsert = [];
        if (!sawEnable) toInsert.push('enable=1');
        if (!sawDisplay) toInsert.push('display-text=1');
        if (!sawTextSize) toInsert.push('text-size=' + textSize);
        if (!sawBg) toInsert.push('text-bg-color=0;0;0;' + bgOpacity);
        if (!sawColor) toInsert.push(`text-color=${r};${g};${b};${alpha}`);
        if (toInsert.length) {
          patched = patched.slice(0, insertAt).concat(toInsert).concat(patched.slice(insertAt));
        }
      }
      const newTxt = patched.join('\n');
      document.getElementById('iniText').value = newTxt;
      try {
        let ptxt = '';
        try {
          const r1 = await fetch('/api/configs/read?path=' + encodeURIComponent(document.getElementById('pgiePath').value || '/app/configs/pgie_resnet10.txt'));
          const j1 = await r1.json();
          if (j1.content !== undefined) { ptxt = j1.content; }
        } catch {}
        if (!ptxt) {
          ptxt = [
            '[property]',
            'gpu-id=0',
            'network-type=0',
            'model-file=/opt/nvidia/deepstream/deepstream-6.0/samples/models/Primary_Detector/resnet10.caffemodel',
            'proto-file=/opt/nvidia/deepstream/deepstream-6.0/samples/models/Primary_Detector/resnet10.prototxt',
            'batch-size=1',
            'interval=0',
            'gie-unique-id=1',
            'maintain-aspect-ratio=1',
            'labelfile-path=/app/configs/labels.txt',
            'net-scale-factor=0.00392156862745098',
            'parse-bbox-func-name=NvDsInferParseCustomBBox_Caffe',
            'custom-lib-path=/opt/nvidia/deepstream/deepstream-6.0/sources/libs/nvdsinfer_custom_impl/libnvdsinfer_custom_impl.so',
            'num-detected-classes=4',
            'cluster-mode=2'
          ].join('\n');
        }
        let plines = ptxt.split(/\r?\n/);
        let ppatched = [];
        let inClassAll = false; let sawClassAll = false; let sawThreshold = false; let classHeaderIndex = -1;
        for (let i = 0; i < plines.length; i++) {
          const l = plines[i];
          const s = l.trim();
          if (s.startsWith('[') && s.endsWith(']')) {
            inClassAll = /\[\s*class-attrs-all\s*\]/i.test(s);
            if (inClassAll) { sawClassAll = true; classHeaderIndex = ppatched.length; }
            ppatched.push(l);
            continue;
          }
          if (inClassAll && /^\s*threshold\s*=\s*/i.test(s)) { ppatched.push('threshold=' + threshold); sawThreshold = true; continue; }
          ppatched.push(l);
        }
        if (!sawClassAll) { ppatched.push('[class-attrs-all]'); classHeaderIndex = ppatched.length - 1; }
        if (!sawThreshold) {
          const insertAt2 = classHeaderIndex + 1;
          ppatched = ppatched.slice(0, insertAt2).concat(['threshold=' + threshold]).concat(ppatched.slice(insertAt2));
        }
        const pPath = document.getElementById('pgiePath').value || '/app/configs/pgie_resnet10.txt';
        const saveR = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: pPath, content: ppatched.join('\n') }) });
        const saveJ = await saveR.json();
        document.getElementById('iniStatus').textContent = 'OSD applied. PGIE threshold: ' + JSON.stringify(saveJ);
      } catch (e) {
        document.getElementById('iniStatus').textContent = e.message;
      }
    }
    function patchSinkRtsp() {
      const port = 8554;
      const udp = 5400;
      let txt = document.getElementById('iniText').value || '';
      let lines = txt.split(/\r?\n/);
      let patched = [];
      let inSink0 = false, sawSink0 = false;
      let sawEnable = false, sawType = false, sawCodec = false, sawEnc = false, sawBitrate = false, sawPort = false, sawUdp = false, sawSync = false, sawQos = false;
      let sinkHeaderIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        const s = l.trim();
        if (/^\s*rtsp-path\s*=\s*/i.test(s)) { /* drop unsupported key */ continue; }
        if (s.startsWith('[') && s.endsWith(']')) {
          inSink0 = /\[\s*sink0\s*\]/i.test(s);
          if (inSink0) { sawSink0 = true; sinkHeaderIndex = patched.length; }
          patched.push(l);
          continue;
        }
        if (inSink0) {
          if (/^\s*enable\s*=\s*/i.test(s)) { patched.push('enable=1'); sawEnable = true; continue; }
          if (/^\s*type\s*=\s*/i.test(s)) { patched.push('type=4'); sawType = true; continue; }
          if (/^\s*codec\s*=\s*/i.test(s)) { patched.push('codec=1'); sawCodec = true; continue; }
          if (/^\s*enc-type\s*=\s*/i.test(s)) { patched.push('enc-type=0'); sawEnc = true; continue; }
          if (/^\s*bitrate\s*=\s*/i.test(s)) { patched.push('bitrate=4000000'); sawBitrate = true; continue; }
          if (/^\s*rtsp-port\s*=\s*/i.test(s)) { patched.push('rtsp-port=' + port); sawPort = true; continue; }
          if (/^\s*udp-port\s*=\s*/i.test(s)) { patched.push('udp-port=' + udp); sawUdp = true; continue; }
          if (/^\s*sync\s*=\s*/i.test(s)) { patched.push('sync=0'); sawSync = true; continue; }
          if (/^\s*qos\s*=\s*/i.test(s)) { patched.push('qos=0'); sawQos = true; continue; }
        }
        patched.push(l);
      }
      if (!sawSink0) { patched.push('[sink0]'); sinkHeaderIndex = patched.length - 1; }
      const toInsert = [];
      if (!sawEnable) toInsert.push('enable=1');
      if (!sawType) toInsert.push('type=4');
      if (!sawCodec) toInsert.push('codec=1');
      if (!sawEnc) toInsert.push('enc-type=0');
      if (!sawBitrate) toInsert.push('bitrate=4000000');
      if (!sawPort) toInsert.push('rtsp-port=' + port);
      if (!sawUdp) toInsert.push('udp-port=' + udp);
      if (!sawSync) toInsert.push('sync=0');
      if (!sawQos) toInsert.push('qos=0');
      if (toInsert.length) { const insertAt = sinkHeaderIndex + 1; patched = patched.slice(0, insertAt).concat(toInsert).concat(patched.slice(insertAt)); }
      document.getElementById('iniText').value = patched.join('\n');
      document.getElementById('iniStatus').textContent = 'RTSP sink applied on port ' + port;
    }
    async function listDsIni() { try { const r = await fetch('/api/configs/list?dir=' + encodeURIComponent('/app/configs/')); const j = await r.json(); const sel = document.getElementById('dsIniList'); sel.innerHTML = ''; if (j && Array.isArray(j.files)) { const prefix = (j && j.dir) || '/app/configs/'; (j.files||[]).forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p.startsWith(prefix) ? p.slice(prefix.length) : p.replace('/app/configs/',''); sel.appendChild(o); }); document.getElementById('dsStatus').textContent = 'Found ' + (j.files||[]).length + ' INIs'; } else { document.getElementById('dsStatus').textContent = (j && j.error) ? j.error : 'No INIs found'; } } catch (e) { document.getElementById('dsStatus').textContent = e.message; } }
    function selectDsIniFromList() { const sel = document.getElementById('dsIniList'); const p = sel.value || ''; const text = document.getElementById('dsUris').value || ''; const lines = text.split(/\r?\n/); lines[0] = p; document.getElementById('dsUris').value = lines.join('\n'); }
    async function loadLabels() { try { const p = document.getElementById('labelsPath').value || ''; const r = await fetch('/api/configs/read?path=' + encodeURIComponent(p)); const j = await r.json(); if (j.content !== undefined) { document.getElementById('labelsText').value = j.content; document.getElementById('labelsStatus').textContent = 'Loaded'; } else { document.getElementById('labelsStatus').textContent = JSON.stringify(j); } } catch (e) { document.getElementById('labelsStatus').textContent = e.message; } }
    async function saveLabels() { try { const p = document.getElementById('labelsPath').value || '/app/configs/labels.txt'; const content = document.getElementById('labelsText').value || ''; const r = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: p, content }) }); const j = await r.json(); document.getElementById('labelsStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('labelsStatus').textContent = e.message; } }
    async function listLabels() { try { const r = await fetch('/api/configs/list?dir=' + encodeURIComponent('/app/configs/') + '&ext=txt'); const j = await r.json(); const sel = document.getElementById('labelsList'); sel.innerHTML=''; if (j && Array.isArray(j.files)) { const prefix = (j && j.dir) || '/app/configs/'; (j.files||[]).forEach(p => { const o=document.createElement('option'); o.value=p; o.textContent=p.startsWith(prefix) ? p.slice(prefix.length) : p.replace('/app/configs/',''); sel.appendChild(o); }); document.getElementById('labelsStatus').textContent = 'Found ' + (j.files||[]).length + ' label files'; } else { document.getElementById('labelsStatus').textContent = (j && j.error) ? j.error : 'No label files found'; } } catch (e) { document.getElementById('labelsStatus').textContent = e.message; } }
    function selectLabelsFromList() { const sel = document.getElementById('labelsList'); const p = sel.value || ''; document.getElementById('labelsPath').value = p; }
    async function listPgie() { try { const r = await fetch('/api/configs/list?dir=' + encodeURIComponent('/app/configs/') + '&ext=txt'); const j = await r.json(); const sel = document.getElementById('pgieList'); sel.innerHTML = ''; if (j && Array.isArray(j.files)) { const prefix = (j && j.dir) || '/app/configs/'; (j.files||[]).forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p.startsWith(prefix) ? p.slice(prefix.length) : p.replace('/app/configs/',''); sel.appendChild(o); }); document.getElementById('pgieStatus').textContent = 'Found ' + (j.files||[]).length + ' PGIE configs'; } else { document.getElementById('pgieStatus').textContent = (j && j.error) ? j.error : 'No PGIE configs found'; } } catch (e) { document.getElementById('pgieStatus').textContent = e.message; } }
    function selectPgieFromList() { const sel = document.getElementById('pgieList'); const p = sel.value || ''; document.getElementById('pgiePath').value = p; }
    async function loadPgie() { try { const p = document.getElementById('pgiePath').value || ''; const r = await fetch('/api/configs/read?path=' + encodeURIComponent(p)); const j = await r.json(); if (j.content !== undefined) { document.getElementById('pgiePreview').value = j.content; document.getElementById('pgieStatus').textContent = 'Loaded'; } else { document.getElementById('pgieStatus').textContent = JSON.stringify(j); } } catch (e) { document.getElementById('pgieStatus').textContent = e.message; } }
    async function savePgie() { try { const p = document.getElementById('pgiePath').value || '/app/configs/pgie_resnet10.txt'; const content = document.getElementById('pgiePreview').value || ''; const r = await fetch('/api/configs/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: p, content }) }); const j = await r.json(); document.getElementById('pgieStatus').textContent = JSON.stringify(j); } catch (e) { document.getElementById('pgieStatus').textContent = e.message; } }
  </script>
</body>
</html>
